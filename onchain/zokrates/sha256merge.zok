import "hashes/sha256/512bitPadded" as sha256

const u32[8] merge_root= [
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
]

// 0 - if hash1 < hash2
// 1 - if hash1 == hash2
// 2 - if hash1 > hash2
def compareHash(u32[8] hash1, u32[8] hash2) -> u8:
    u8 result = 1
    for u32 i in 0..8 do
        result = if hash1[7-i] == hash2[7-i] then result else if hash1[7-i] < hash2[7-i] then 0 else 2 fi fi
    endfor
    return result

def verifyProofDepth3(private u32[3][8] proof, private u32[8] leaf, u32[8] root) -> bool:
    // make path a 2d array
    u32[8] proofHash = leaf
    for u32 i in 0..3 do
        proofHash = if compareHash(proofHash, proof[i]) == 0 then sha256(proofHash, proof[i]) else sha256(path[i], proof) fi
    endfor
    return if compareHash(proofHash, root) == 1 then true else false fi

def verifyMerge(private u32[1][8] merge_proof, private u32[8] card1_IDleaf, private u32[8] card2_IDleaf, private u32[8] card3_IDleaf, u32[8] merge_root) -> bool:
    u32[8] dummyblock1 = [0x80000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000300]
    // proof starts with leaf, which is hash of the three card leaves
    u32[8] proofHash = sha1024(card1_IDleaf,card2_IDleaf,card3_IDleaf,dummyblock1)
    for u32 i in 0..1 do
        proofHash = if compareHash(proofHash, proof[i]) == 0 then sha256(proofHash, proof[i]) else sha256(path[i], proof) fi
    endfor
    return if compareHash(proofHash, merge_root) == 1 then true else false fi

def main(private u32[3][8] card1_path, private u32[8] card1_IDleaf, u32[8] card1_root, private u32[3][8] card2_path, private u32[8] card2_IDleaf, u32[8] card2_root, private u32[1][8] merge_proof, private u32[8] card3_IDleaf) -> u32[8]: // change this to card1_ID
    assert(verifyProofDepth3(card1_path,card1_IDleaf,card1_root))
    assert(verifyProofDepth3(card2_path,card2_IDleaf,card2_root))
    assert(verifyMerge)
